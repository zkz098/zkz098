const CACHE_NAME="KaitakuCDNCache";let cachelist=[];let flag=false;const cdn={gh:{jsdelivr:{url:"https://cdn.jsdelivr.net/gh"},jsdelivr_fastly:{url:"https://fastly.jsdelivr.net/gh"},jsdelivr_kaitaku:{url:"https://jsd.kaitaku.xyz/gh"}},cdnjs:{staticfile:{url:"https://cdn.staticfile.org"},cdnjs_cf:{url:"https://cdnjs.cloudflare.com/ajax/libs"},baomitu:{url:"https://lib.baomitu.com"},bytedance:{url:"https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M"}},npm:{eleme:{url:"https://npm.elemecdn.com"},sourcegcdn:{url:"https://npm.sourcegcdn.com"},unpkg:{url:"https://unpkg.com"},tianli:{url:"https://cdn1.tianli0.top/npm"}}};const info=e=>{console.log(`%c INFO %c ${e}`,"color: white; background: #32cd32; padding: 5px 3px;","padding: 4px;border:1px solid #32cd32")};const warn=e=>{console.log(`%c WARN %c ${e}`,"color: white; background: #ffd700; padding: 5px 3px;","padding: 4px;border:1px solid #ffd700")};const err=e=>{console.log(`%c ERROR %c ${e}`,"color: white; background: #ff0000; padding: 5px 3px;","padding: 4px;border:1px solid #ff0000")};const handleerr=async(e,t)=>{return new Response(`<h1>KaitakuCDNCache遇到了致命错误</h1>
    <b>${t}</b>`,{headers:{"content-type":"text/html; charset=utf-8"}})};const file_found=(e,t)=>{return e.indexOf(t)>-1};const handle=async c=>{const r=c.url;const e=c.url.split("/")[2];let s=[];if(file_found(r,"woff")||file_found(r,"jpg")||file_found(r,"ico")){return caches.match(c).then(function(e){return e||fetch(r).then(function(t){return caches.open(CACHE_NAME).then(function(e){e.put(c,t.clone());return t})})})}else if(e.match("fundingchoicesmessages.google.com")){info("fetch fundingchoicesmessages succeed");return fetch(c.url.replace("https://fundingchoicesmessages.google.com","https://adsenseabc.vercel.app"))}else{for(let n in cdn){for(let t in cdn[n]){if(e===cdn[n][t].url.split("https://")[1].split("/")[0]&&r.match(cdn[n][t].url)){info(`capture ${r}`);s=[];for(let e in cdn[n]){s.push(r.replace(cdn[n][t].url,cdn[n][e].url))}if(r.indexOf("@latest/")>-1){return lfetch(s,r)}else{return caches.match(c).then(function(e){return e||lfetch(s,r).then(function(t){return caches.open(CACHE_NAME).then(function(e){e.put(c,t.clone());return t})})})}}}}return fetch(c)}};const lfetch=async(e,t)=>{info(`lfetch handle! | mirrors: ${e.length}`);let c=new AbortController;const r=async e=>{return new Response(await e.arrayBuffer(),{status:e.status,headers:e.headers})};if(!Promise.any){Promise.any=function(e){return new Promise((t,n)=>{e=Array.isArray(e)?e:[];let c=e.length;let r=[];if(c===0)return n(new AggregateError("All promises were rejected"));e.forEach(e=>{e.then(e=>{t(e)},e=>{c--;r.push(e);if(c===0){n(new AggregateError(r))}})})})}}return Promise.any(e.map(e=>{return new Promise((t,n)=>{fetch(e,{signal:c.signal}).then(r).then(async e=>{if(e.status===200){c.abort();t(e)}else{n(e)}}).catch(async e=>{if(!flag){warn("fetch: "+e);flag=true}})})}))};self.addEventListener("install",async e=>{await self.skipWaiting();e.waitUntil(caches.open(CACHE_NAME).then(e=>{info(`${CACHE_NAME} Opened`);info(`${CACHE_NAME} start running`);return e.addAll(cachelist)}))});self.addEventListener("activate",async function(e){await self.clients.claim()});self.addEventListener("fetch",async t=>{try{t.respondWith(handle(t.request))}catch(e){t.respondWith(handleerr(t.request,e))}});